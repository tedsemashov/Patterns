# Patterns
Design patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.

# Behaviour
1. **chain of resposibility**	дає змогу передавати запити послідовно ланцюжком обробників. По суті викликаємо метод за методом. Типу як Promise разом з then(). FE: авторизація і тільки тоді вхід

2. **command**	додаткова оболонка яка дозволяє нам працювати з нашим основним класом. Легко викликати його методи і збергігати якусь додаткову інформацію. Логи і тд.

3. **iterator**	дає змогу послідовно обходити елементи складових об’єктів, не розкриваючи їхньої внутрішньої організації. Створюємо функцію яка послідовно отримує доступ до інформації. Функції генератори.

4. **mediator**	вибудовує тісні звязки між класами шляхом створення одного класу-посередника. Наприклад чат який взаємодії з різними класами.

5. **observer**	створює механізм підписки, що дає змогу одним об’єктам стежити й реагувати на події, які відбуваються в інших об’єктах. Спостерігачі слідкують за предметом і змінюються відповідно до його змін. повідомляє їх про будь-які зміни стану: зазвичай, викликаючи один з їхніх методів.

6. **state**	обєкти можуть змінювати поведінку в залежності від стану.

7. **strategy**	створити спільну абстракцію щоб винести спільний метод.

8. **template**	патерн дозволяє підкласам перевизначати кроки алгоритму, не змінюючи його загальної структури. Діти перезаписують метод батька(абстракції).

# Creational
1. **constructor**	створення і ініціалізація новоствореного примірника класу. Те що буде приймати клас ззовні і записувати в стейт собі щоб потім використовувати всередині для методів класу.

2. **factory**	визначає загальний інтерфейс для створення об’єктів у суперкласі, дозволяючи підкласам змінювати тип створюваних об’єктів. Реалізація метода батька відбувається в дітях по своєму.

3. **prototype**	дає змогу копіювати методи об’єктів. Може бути надлишковість. 

4. **singleton**	гарантує, що клас має лише один екземпляр, та надає глобальну точку доступу до нього. Всі наступні будуть повертати той самий об'єкт.

# Structural
1. **adapter**	дозволяє інтегрувати старий інтерфейс в новий і апка не зламалась. Допомагає працювати двом несумісним обєктам, конвертує, переробляє структуру і тд.

2. **decorator**	дозволяє динамічно додавати нову функціональнфсть із допомогою обгортки (HOC). Декорує поточний обєкт, клас і тд.

3. **facade**	простий інтерфейс до складної системи класів. Місце де відбувається основна логіка роботи з іншими класами. «Фасад» передбачає API.

4. **flyweight**	дає змогу вмістити більшу кількість об’єктів у відведеній оперативній пам’яті. Кешування, зберігання памяті. Відео, фото.

5. **proxy**	об’єкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось до чи після передачі виклику оригіналові. Дозволяє ставити ловушки щоб оприділяти роботу апки, щоб уникнути лишні запити на АПІ наприкладю
